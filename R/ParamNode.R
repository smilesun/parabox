#' @title Parameter Node Object
#' @format \code{\link{R6Class}} object
#'
#' @description
#' A \code{\link[R6]{R6Class}} to represent parameters.
#'
#' @section Member Variables:
#'
#' \describe{
#'   \item{id}{[\code{character}] \cr Unique id.}
#'   \item{storage_type}{[\code{character(1)}] \cr How are values for this Parameter represented as an R object.}
#'   \item{check}{[\code{function}] \cr A function that returns \code{TRUE} for valid parameter values and a \code{character} if the value is not valid.}
#'   \item{assert}{[\code{function}] \cr A assert_ion generated by \code{\link[checkmate]{makeAssertionFunction}} from the \code{check} function.}
#'   \item{test}{[\code{function}] \cr A test generated by \code{\link[checkmate]{makeTestFunction}} from the \code{check} function.}
#'   \item{tags}{[\code{character}] \cr A vector of \code{characters} that indicate special properties of this Parameter.}
#' }
#'
#' @section Methods:
#'
#' \describe{
#'   \item{sample(n)}{[\code{function}] \cr Function to sample Parameter values. Always returns a \code{data.table}.}
#'   \item{denorm(x)}{[\code{function}] \cr Takes a named list. Each list item contains a numerical vector with values between \code{[0,1]}. These values will be mapped to values of the Parameter Space.}
#' }
#'
#' @section Active Bindings:
#'
#' \describe{
#'   \item{has_finite_bounds}{\code{logical(1)} \cr Does the Parameter have finite bounds.}
#' }
#'
#' @return [\code{\link{ParamNode}}].
#' @family ParamHelpers
ParamNode = R6Class("ParamNode",
  inherit = ParamBase,
  public = list(

    # member variables
    id = NULL, # string to uniquely identify this param
    handle = NULL, # additional stuff
    storage_type = NULL, # of what R data storage_type can values of this parameter be stored?
    check = NULL, # a checkmate check function to validate if a value is valid for this Param
    assert = NULL, # assert_ion generated from the above check
    test = NULL, # test generated from the above check
    tags = NULL, # additional properties like "on_train", "on_test" or "tunable" for mlr

    # constructor
    initialize = function(id, storage_type, check, tags) {
      handle = handle %??% ParamHandle$new()
      assert_string(id)
      self$id = assert_names(id, type = "strict")
      self$storage_type = assert_string(storage_type)
      self$check = assert_function(check)
      self$test = makeTestFunction(check)
      self$assert = makeAssertionFunction(check)
      self$handle = assert_r6(handle, "ParamHandle")
      self$tags = assert_character(tags, null.ok = TRUE)
    },

    # public methods
    sample = function(n = 1L) {
      stop("sample not implemented")
    },
    denorm = function(x) {
      stop("denorm not implemented")
    }
  ),
  active = list(
    has_finite_bounds = function() NA
  )
)
